# Copyright 2022 Observational Health Data Sciences and Informatics
#
# This file is part of DiscoverySystemSimulator
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# library(dplyr)
# library(purrr)

#' Compute confusion matrix
#'
#' @param signals            An object created using [runDiscoverySystem()].
#' @param simulationSettings An object created using [createSimulationSettings()].
#' @param level              The level at which to compute the confusion matrix. Currently
#'                           supports "exposure-outcome" and "across looks".
#'
#' @return
#' A tibble.
#'
#' @export
computeConfusionMatrix <- function(signals, simulationSettings, level = "exposure-outcome") {
  negativeControlIds <- getNegativeControlIds(simulationSettings)

  if (level == "exposure-outcome") {
    signalsPerExposureOutcome <- signals %>%
      group_by(.data$exposureOutcomeId)
  } else if (level == "across looks") {
    signalsPerExposureOutcome <- signals %>%
      group_by(.data$exposureOutcomeId, .data$databaseId, .data$methodId, .data$timeAtRiskId)
  } else {
    stop(sprintf("Unknown level '%s'. Please select 'exposure-outcome' or 'across looks'", level))
  }

  signalsPerExposureOutcome <- signalsPerExposureOutcome %>%
    summarise(signalMaxSprt = any(.data$signalMaxSprt),
              signalCalibratedMaxSprt = any(.data$signalCalibratedMaxSprt),
              signalP = any(.data$signalP),
              .groups = "drop") %>%
    mutate(groundTruth = !.data$exposureOutcomeId %in% negativeControlIds)

  confusionMatrix <- bind_rows(computeMatrix(signalsPerExposureOutcome$signalCalibratedMaxSprt,
                                             signalsPerExposureOutcome$groundTruth,
                                             "Calibrated MaxSPRT"),
                               computeMatrix(signalsPerExposureOutcome$signalMaxSprt,
                                             signalsPerExposureOutcome$groundTruth,
                                             "MaxSPRT"),
                               computeMatrix(signalsPerExposureOutcome$signalP,
                                             signalsPerExposureOutcome$groundTruth,
                                             "P"))
  return(confusionMatrix)
}

computeMatrix <- function(signal, groundTruth, label) {
  tp <- sum(signal & groundTruth)
  fp <- sum(signal & !groundTruth)
  tn <- sum(!signal & !groundTruth)
  fn <- sum(!signal & groundTruth)
  tibble(tp = tp,
         fp = fp,
         tn = tn,
         fn = fn,
         type1 = fp / (fp + tn),
         type2 = fn / (tp + fn),
         label = label) %>%
    return()
}





#' Plot distribution of false positives and negatives
#'
#' @param confusionMatrices An object generated by [evaluateIterations()].
#' @param labels            Which labels to plot? (Values of the `label` column). If `NULL` then all values are plotted.
#' @param cumulative        Should cumulative probabilities be shown?
#' @param alpha             The nominal alpha to plot. NA for no alpha.
#' @param fileName          Optional: the name of the file to save the plot to.
#'
#' @return
#' A GGPlot object.
#'
#' @export
plotFalsePositiveNegatives <- function(confusionMatrices,
                                       labels = NULL,
                                       facet = NULL,
                                       cumulative = TRUE,
                                       alpha = 0.05,
                                       fileName = NULL) {
  if (is.null(labels)) {
    labels <- unique(confusionMatrices$label)
  }

  nIterations <- length(unique(confusionMatrices$iteration))

  plotData <- confusionMatrices %>%
    filter(.data$label %in% labels) %>%
    select(.data$fp, .data$fn, .data$label, .data$iteration) %>%
    tidyr::pivot_longer(cols = c("fp", "fn"), values_to = "count", names_to = "type") %>%
    group_by(.data$label, .data$type, .data$count) %>%
    summarize(percentage = 100* n() / nIterations, .groups = "drop") %>%
    mutate(type = recode(.data$type, fp = "False positive", fn = "False negative"))

  if (cumulative) {
    plotData <- plotData %>%
      filter(.data$count != 0)

    toAdd <- plotData %>%
      group_by(.data$label, .data$type) %>%
      summarize(minCount = min(.data$count) - 1, .groups = "drop") %>%
      filter(.data$minCount > 0)
    if (nrow(toAdd) > 0) {
      for (i in 1:nrow(toAdd)) {
        plotData <- bind_rows(tibble(label = toAdd$label[i],
                                     type = toAdd$type[i],
                                     count = 1:toAdd$minCount[i],
                                     percentage = 0),
                              plotData)
      }
    }

    plotData <- plotData %>%
      group_by(.data$label, .data$type) %>%
      arrange(desc(.data$count)) %>%
      mutate(percentage = cumsum(.data$percentage)) %>%
      ungroup()
    yLabel <- "Cumulative probability (%)"
  } else {
    yLabel <- "Probability (%)"
  }

  plotData$label <- factor(plotData$label, levels = labels)
  plot <- ggplot2::ggplot(plotData, ggplot2::aes(x = as.factor(.data$count), y = .data$percentage)) +
    ggplot2::geom_hline(ggplot2::aes(yintercept = .data$percentage), linetype = "dashed", data = tibble(percentage = alpha * 100,
                                                                                                        type = "False positive")) +
    ggplot2::geom_bar(stat = "identity") +
    ggplot2::scale_x_discrete("Number of misclassified estimates") +
    ggplot2::scale_y_continuous(yLabel) +
    ggplot2::facet_grid(label ~ type, scales = "free_x")

  if (!is.null(fileName)) {
    ggplot2::ggsave(plot = plot,
                    filename = fileName,
                    width = 8,
                    height = 2 + length(labels) * 2,
                    dpi =  200)
  }

  return(plot)
}
