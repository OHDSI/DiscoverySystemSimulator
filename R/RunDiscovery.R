# Copyright 2023 Observational Health Data Sciences and Informatics
#
# This file is part of DiscoverySystemSimulator
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# library(dplyr)
# library(purrr)
# simulation <- readRDS(file.path(simulationsFolder, "Simulation_i1.rds"))
# cacheFolder <- file.path(simulationsFolder, "Cache_i1")

#' Create setting for the discovery system
#'
#' @param alpha                The family-wise type 1 error rate we're aiming for. Can be a grid of values.
#' @param databaseIdsToIgnore  A list of database IDs to ignore (first database has ID 1, second 2, etc.).
#' @param methodIdsToIgnore    A list of method IDs to ignore (first method has ID 1, method 2, etc.).
#'
#' @return
#' A settings object
#'
#' @export
createDiscoverySystemSettings <- function(alpha = exp(seq(log(0.05), log(5), length.out = 10)),
                                          databaseIdsToIgnore = c(),
                                          methodIdsToIgnore = c(),
                                          useMaxSprt = TRUE,
                                          useCalibratedMaxSprt = TRUE,
                                          useLocalP = TRUE,
                                          useLocalCalibratedP = TRUE,
                                          useMetaAnalysisP = TRUE,
                                          useMetaAnalysisCalibratedP = TRUE) {
  settings <- list()
  for (name in names(formals(createDiscoverySystemSettings))) {
    settings[[name]] <- get(name)
  }
  return(settings)
}


#' Run discovery system
#'
#' @param simulation              An object generated by [simulateDiscoverySystem()].
#' @param discoverySystemSettings An object generated by [createDiscoverySystemSettings()].
#' @param cacheFolder             Optionally, a folder where intermediate artifacts (e.g. fitted
#'                                systematic error distributions) can be cached. If `NULL`, no
#'                                caching is performed.
#'
#' @return
#' Returns a tibble with signal flags for each row in the simulation.
#'
#' @export
runDiscoverySystem <- function(simulation = simulateDiscoverySystem(),
                               discoverySystemSettings = createDiscoverySystemSettings(),
                               cacheFolder = NULL) {
  if (!is.null(cacheFolder) && !dir.exists(cacheFolder)) {
    message(sprintf("Folder '%s' does not exist, so creating it.", cacheFolder))
    dir.create(cacheFolder, recursive = TRUE)
  }
  if (length(discoverySystemSettings$databaseIdsToIgnore) > 0) {
    message(sprintf("Removing database ID(s) %s from the simulation.",
                    paste(discoverySystemSettings$databaseIdsToIgnore, collapse = ",")))
    simulation <- simulation %>%
      filter(!.data$databaseId %in% discoverySystemSettings$databaseIdsToIgnore)
  }
  if (length(discoverySystemSettings$methodIdsToIgnore) > 0) {
    message(sprintf("Removing method ID(s) %s from the simulation.",
                    paste(discoverySystemSettings$methodIdsToIgnore, collapse = ",")))
    simulation <- simulation %>%
      filter(!.data$methodId %in% discoverySystemSettings$methodIdsToIgnore)
  }
  nExposureOutcomes <- simulation %>%
    distinct(.data$exposureOutcomeId) %>%
    count() %>%
    pull()
  nTars <- simulation %>%
    distinct(.data$timeAtRiskId) %>%
    count() %>%
    pull()
  nMethods <- simulation %>%
    distinct(.data$methodId) %>%
    count() %>%
    pull()
  nDatabases <- simulation %>%
    distinct(.data$databaseId) %>%
    count() %>%
    pull()
  alphaLocal <- tibble(alpha = discoverySystemSettings$alpha,
                       alphaLocal = discoverySystemSettings$alpha / nExposureOutcomes / nTars / nMethods / nDatabases,
                       alphaMetaAnalysis = discoverySystemSettings$alpha / nExposureOutcomes / nTars / nMethods)
  if (discoverySystemSettings$useLocalP ||
      discoverySystemSettings$useLocalCalibratedP ||
      discoverySystemSettings$useMaxSprt ||
      discoverySystemSettings$useCalibratedMaxSprt) {
    signalsLocal <- computeLocalSignals(simulation = simulation,
                                        alphaLocal = alphaLocal,
                                        discoverySystemSettings = discoverySystemSettings,
                                        cacheFolder = cacheFolder)
  } else {
    signalsLocal <- NULL
  }

  if (discoverySystemSettings$useMetaAnalysisP ||
      discoverySystemSettings$useMetaAnalysisCalibratedP) {
    signalsMetaAnalysis <- computeMetaAnlysisSignals(simulation = simulation,
                                                     alphaLocal = alphaLocal,
                                                     discoverySystemSettings = discoverySystemSettings,
                                                     cacheFolder = cacheFolder)
  } else {
    signalsMetaAnalysis <- NULL
  }
  return(bind_rows(signalsLocal, signalsMetaAnalysis))
}

computeLocalSignals <- function(simulation,
                                alphaLocal,
                                discoverySystemSettings,
                                cacheFolder) {
  estimates <- simulation %>%
    select("methodId", "timeAtRiskId", "exposureOutcomeId", "databaseId", "lookId", "p", "llr") %>%
    cross_join(alphaLocal)
  if (discoverySystemSettings$useLocalP) {
    estimates <- estimates %>%
      mutate(signalP = if_else(is.na(.data$p), FALSE, .data$p < .data$alphaLocal))
  }
  if (discoverySystemSettings$useCalibratedMaxSprt || discoverySystemSettings$useLocalCalibratedP) {
    distributions <- fitSystematicErrorDistributions(simulation, cacheFolder)
    if (discoverySystemSettings$useLocalCalibratedP) {
      calibratedPs <- computeCalibratedPs(simulation, distributions)
      estimates <- estimates%>%
        inner_join(calibratedPs %>%
                     select("methodId", "timeAtRiskId", "exposureOutcomeId", "databaseId", "lookId", "calibratedP"),
                   by = join_by(methodId, timeAtRiskId, exposureOutcomeId, databaseId, lookId)) %>%
        mutate(signalCalibratedP = if_else(is.na(.data$calibratedP), FALSE, .data$calibratedP < .data$alphaLocal))
    }
  } else {
    distributions <- NULL
  }
  if (discoverySystemSettings$useMaxSprt || discoverySystemSettings$useCalibratedMaxSprt) {
    criticalValues <- computeCriticalValues(simulation = simulation,
                                            alphaLocal = alphaLocal,
                                            distributions = distributions,
                                            discoverySystemSettings = discoverySystemSettings,
                                            cacheFolder = cacheFolder)
    estimates <- estimates %>%
      inner_join(criticalValues, by = join_by("methodId", "timeAtRiskId", "exposureOutcomeId", "databaseId"))
    if (discoverySystemSettings$useMaxSprt) {
      estimates <- estimates %>%
        mutate(signalMaxSprt = .data$llr > .data$cv)
    }
    if (discoverySystemSettings$useCalibratedMaxSprt) {
      estimates <- estimates %>%
        mutate(signalCalibratedMaxSprt = .data$llr > .data$calibratedCv)
    }
  }
  signals <- squashSignals(estimates)
  return(signals)
}

squashSignals <- function(signals) {
  # Convert so we have first look when method signals:
  pivot <- signals %>%
    tidyr::pivot_longer(cols = starts_with("signal"),
                        names_to = "detectionMethod",
                        values_to = "signal") %>%
    mutate(label = case_when(
      .data$detectionMethod == "signalCalibratedMaxSprt" ~ "Calibrated MaxSPRT",
      .data$detectionMethod == "signalCalibratedP" ~ "Calibrated P",
      .data$detectionMethod == "signalMaxSprt" ~ "MaxSPRT",
      .data$detectionMethod == "signalP" ~ "P",
      .data$detectionMethod == "signalMetaAnalysisP" ~ "Meta-analysis P",
      .data$detectionMethod == "signalMetaAnalysisCalibratedP" ~ "Meta-analysis calibrated P"
    )) %>%
    select(-"detectionMethod")
  signals <- pivot %>%
    filter(.data$signal) %>%
    group_by(.data$exposureOutcomeId, .data$label, .data$alpha) %>%
    summarize(lookId = min(.data$lookId, na.rm = TRUE), .groups = "drop")
  signals <- pivot %>%
    distinct(.data$exposureOutcomeId, .data$label, .data$alpha) %>%
    left_join(signals, by = join_by("exposureOutcomeId", "label", "alpha")) %>%
    mutate(lookId = if_else(is.na(.data$lookId), Inf, .data$lookId))
  return(signals)
}

computeCalibratedPs <- function(simulation, distributions) {
  groups <- simulation %>%
    inner_join(distributions, by = c("methodId", "timeAtRiskId", "databaseId", "lookId")) %>%
    group_by(.data$systematicErrorMean , .data$systematicErrorSd) %>%
    group_split()

  calibrateP <- function(group) {
    null <- c(group$systematicErrorMean[1], group$systematicErrorSd[1])
    class(null) <- "null"
    calibratedP <- EmpiricalCalibration::calibrateP(null = null, logRr = group$logRr, seLogRr = group$seLogRr, twoSided = FALSE, upper = TRUE)
    group %>%
      mutate(calibratedP = !!calibratedP) %>%
      return()
  }
  results <- map_dfr(groups, calibrateP) %>%
    select(-"systematicErrorMean", -"systematicErrorSd")
  return(results)
}

dropNonStandardAttributes <- function(object) {
  standard <- names(attributes(tibble()))
  attributes(object) <- attributes(object)[standard]
  return(object)
}

fitSystematicErrorDistributions <- function(simulation, cacheFolder, normalApproximation = FALSE) {
  if (!is.null(cacheFolder)) {
    cacheFile <- file.path(cacheFolder, "SystematicErrorDistributions.rds")
    cache <- TRUE
  } else {
    cache <- FALSE
  }
  if (cache && file.exists(cacheFile)) {
    message("Loading systematic error distributions from ", cacheFile)
    distributions <- readRDS(cacheFile)
  } else {
    # Using all simulated exposure-outcome pairs with null effect as negative controls:
    negativeControlIds <- getNegativeControlIds(attr(simulation, "simulationSettings"))

    message("Fitting systematic error distributions")
    # subset <- split(simulation, paste(simulation$databaseId, simulation$timeAtRiskId, simulation$methodId, simulation$lookId))[[1]]
    fitDistribution <- function(subset) {
      negativeControls <- subset %>%
        filter(.data$exposureOutcomeId %in% negativeControlIds)
      if (normalApproximation) {
        suppressMessages(
          distribution <- EmpiricalCalibration::fitNull(subset$logRr, subset$seLogRr)
        )
      } else {
        profiles <- attr(simulation, "profiles")[negativeControls$profileIdx]
        profiles <- profiles %>%
          discard(is.null)
        suppressMessages(
          distribution <- EmpiricalCalibration::fitNullNonNormalLl(profiles)
        )
      }
      tibble(databaseId = subset$databaseId[1],
             timeAtRiskId = subset$timeAtRiskId[1],
             methodId = subset$methodId[1],
             lookId = subset$lookId[1],
             systematicErrorMean = distribution[1],
             systematicErrorSd = distribution[2]) %>%
        return()
    }
    distributions <- map(split(simulation, paste(simulation$databaseId,
                                                 simulation$timeAtRiskId,
                                                 simulation$methodId,
                                                 simulation$lookId)),
                         fitDistribution) %>%
      list_rbind()
    if (cache) {
      saveRDS(distributions, cacheFile)
    }
  }
  return(distributions)
}

computeExposureAndExpectedCounts <- function(exposureOutcomeId, simulationSettings) {
  exposureOutcomeSettings <- simulationSettings$exposureOutcomeSettings[[exposureOutcomeId]]
  lookIds <- seq_len(simulationSettings$looks)
  nTarget <- map_dbl(lookIds,
                     computeNtarget,
                     nTargetFirstLook = exposureOutcomeSettings$nTargetFirstLook,
                     nTargetNextLooks = exposureOutcomeSettings$nTargetNextLooks,
                     nTargetNextLooksDelta = exposureOutcomeSettings$nTargetNextLooksDelta)
  nComparator <- nTarget * exposureOutcomeSettings$nComparatorMultiplier
  expectedEventsPerDay <- (nTarget + nComparator) * exposureOutcomeSettings$backgroundRate
  return(tibble(exposureOutcomeId = exposureOutcomeId,
                lookId = lookIds,
                z = nComparator / nTarget,
                expectedEventsPerDay))
}

computeCriticalValues <- function(simulation, alphaLocal, distributions, discoverySystemSettings, cacheFolder) {
  if (!is.null(cacheFolder)) {
    cacheFile <- file.path(cacheFolder, "CriticalValues.rds")
    cache <- TRUE
  } else {
    cache <- FALSE
  }

  if (cache && file.exists(cacheFile)) {
    message("Loading critical values from ", cacheFile)
    criticalValues <- readRDS(cacheFile)
  } else {
    simulationSettings <- attr(simulation, "simulationSettings")
    exposureOutcomeSettings <- map(seq_along(simulationSettings$exposureOutcomeSettings),
                                   computeExposureAndExpectedCounts,
                                   simulationSettings = simulationSettings) %>%
      list_rbind()
    databaseSettings <- map(simulationSettings$databaseSettings,
                            function(x) return(tibble(sampleSizeMultiplier = x$sampleSizeMultiplier)))  %>%
      list_rbind() %>%
      mutate(databaseId = row_number())
    timeAtRiskSettings <- map(simulationSettings$timeAtRiskSettings,
                              function(x) return(tibble(start = x$start, end = x$end))) %>%
      list_rbind() %>%
      mutate(timeAtRiskId  = row_number())
    valuesForUncalibratedCv <- exposureOutcomeSettings %>%
      cross_join(databaseSettings) %>%
      cross_join(timeAtRiskSettings) %>%
      cross_join(tibble(methodId = seq_along(simulationSettings$methodSettings))) %>%
      cross_join(alphaLocal) %>%
      mutate(expectedEvents = .data$expectedEventsPerDay * .data$sampleSizeMultiplier * (.data$end - .data$start + 1)) %>%
      select(
        "exposureOutcomeId",
        "databaseId",
        "timeAtRiskId",
        "methodId",
        "lookId",
        "alphaLocal",
        "z",
        "expectedEvents"
      ) %>%
      mutate(systematicErrorMean = 0,
             systematicErrorSd = 0) %>%
      ungroup()

    if (discoverySystemSettings$useMaxSprt) {
      pivot <- valuesForUncalibratedCv %>%
        tidyr::pivot_wider(
          names_from = "lookId",
          names_prefix = "look_",
          values_from = "expectedEvents")
      groups <- pivot %>%
        select("alphaLocal", "z", starts_with("look_"), "systematicErrorMean", "systematicErrorSd") %>%
        distinct() %>%
        group_by(dummy = row_number()) %>%
        group_split()
      message("Computing critical values")
      cvsForUncalibratedCv <- map(groups, computeCv) %>%
        list_rbind()
      cvsForUncalibratedCv <- cvsForUncalibratedCv %>%
        inner_join(pivot) %>%
        select("exposureOutcomeId", "databaseId", "timeAtRiskId", "methodId", "cv", "cvAlpha", "alphaLocal")
      criticalValues <- cvsForUncalibratedCv
    }
    if (discoverySystemSettings$useCalibratedMaxSprt) {
      valuesForCalibratedCv <- valuesForUncalibratedCv %>%
        select(-"systematicErrorMean", -"systematicErrorSd") %>%
        inner_join(distributions %>%
                     filter(.data$lookId == max(.data$lookId)) %>%
                     select(-"lookId"),
                   by = c("databaseId", "methodId", "timeAtRiskId"), relationship = "many-to-many")
      pivot <- valuesForCalibratedCv %>%
        tidyr::pivot_wider(
          names_from = "lookId",
          names_prefix = "look_",
          values_from = "expectedEvents")
      groups <- pivot %>%
        select("alphaLocal", "z", starts_with("look_"), "systematicErrorMean", "systematicErrorSd") %>%
        distinct() %>%
        group_by(dummy = row_number()) %>%
        group_split()
      message("Computing critical values")
      cvsForCalibratedCv <- map(groups, computeCv) %>%
        list_rbind()
      cvsForCalibratedCv <- cvsForCalibratedCv %>%
        inner_join(pivot) %>%
        select("exposureOutcomeId", "databaseId", "timeAtRiskId", "methodId", "cv", "cvAlpha", "alphaLocal") %>%
        rename(calibratedCv = "cv",
               calibratedCvAlpha = "cvAlpha")
      if (discoverySystemSettings$useMaxSprt) {
        criticalValues <- criticalValues %>%
          inner_join(cvsForCalibratedCv, by = join_by("exposureOutcomeId", "databaseId", "timeAtRiskId", "methodId", "alphaLocal"))
      } else {
        criticalValues <- cvsForCalibratedCv
      }
    }
    if (cache) {
      saveRDS(criticalValues, cacheFile)
    }
  }
  return(criticalValues)
}

computeMetaAnlysisSignals <- function(simulation,
                                      alphaLocal,
                                      discoverySystemSettings,
                                      cacheFolder) {
  if (!is.null(cacheFolder)) {
    cacheFile <- file.path(cacheFolder, "MetaAnalysisEstimates.rds")
    cache <- TRUE
  } else {
    cache <- FALSE
  }
  if (cache && file.exists(cacheFile)) {
    message("Loading meta-analysis estimates from ", cacheFile)
    estimates <- readRDS(cacheFile)
  } else {
    groups <- simulation %>%
      group_by(.data$methodId, .data$timeAtRiskId, .data$exposureOutcomeId, .data$lookId) %>%
      group_split()
    allProfiles <- attr(simulation, "profiles")
    performMetaAnalysis <- function(group) {
      profiles = allProfiles[group$profileIdx]
      estimate <- EvidenceSynthesis::computeBayesianMetaAnalysis(profiles)
      row <- group %>%
        head(1) %>%
        select("methodId", "timeAtRiskId", "exposureOutcomeId", "lookId") %>%
        mutate(logRr = estimate$mu,
               seLogRr = estimate$muSe,
               p = mean(attr(estimate, "traces")[, 1] < 0))
      return(row)
    }
    estimates <- lapply(groups, performMetaAnalysis)
    estimates <- bind_rows(estimates)
    if (cache) {
      saveRDS(estimates, cacheFile)
    }
  }
  signals <- estimates %>%
    cross_join(alphaLocal)
  if (discoverySystemSettings$useMetaAnalysisP) {
    signals <- signals %>%
      mutate(signalMetaAnalysisP = if_else(is.na(.data$p), FALSE, .data$p < .data$alphaMetaAnalysis))
  }
  if (discoverySystemSettings$useMetaAnalysisCalibratedP) {
    estimates$databaseId <- 0
    attr(estimates, "simulationSettings") <- attr(simulation, "simulationSettings")
    distributions <- fitSystematicErrorDistributions(simulation = estimates,
                                                     cacheFolder = NULL,
                                                     normalApproximation = TRUE)
    calibratedPs <- computeCalibratedPs(simulation = estimates,
                                        distributions = distributions)
    signals <- signals %>%
      inner_join(
        calibratedPs %>%
          select("methodId", "timeAtRiskId", "exposureOutcomeId", "lookId", "calibratedP"),
        by = join_by("methodId", "timeAtRiskId", "exposureOutcomeId", "lookId")
      )  %>%
      mutate(signalMetaAnalysisCalibratedP = if_else(is.na(.data$p), FALSE, .data$calibratedP < .data$alphaMetaAnalysis))

  }
  signals <- squashSignals(signals)
  return(signals)
}
